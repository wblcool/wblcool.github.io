(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{386:function(e,s,r){"use strict";r.r(s);var t=r(42),a=Object(t.a)({},(function(){var e=this,s=e.$createElement,r=e._self._c||s;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p"),r("div",{staticClass:"table-of-contents"},[r("ul",[r("li",[r("a",{attrs:{href:"#基本背景"}},[e._v("基本背景")])]),r("li",[r("a",{attrs:{href:"#promise基础知识"}},[e._v("Promise基础知识")])])])]),r("p"),e._v(" "),r("h3",{attrs:{id:"基本背景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基本背景"}},[e._v("#")]),e._v(" 基本背景")]),e._v(" "),r("p",[e._v("js引擎是基于单线程事件循环的概念构建的。同一时刻只允许一个代码块在执行。\njs引擎同一时刻只能执行一个代码块，所以需要跟踪即将运行的代码，那些代码被挡在一个任务队列中，每当一段代码准备执行时，都会被添加到任务队列。每当js引擎中的一段代码结束执行，事件循环会执行队列中的下一个任务，它是js引擎中的的一段程序，负责监控代码执行并管理任务队列。")]),e._v(" "),r("h4",{attrs:{id:"事件模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#事件模型"}},[e._v("#")]),e._v(" 事件模型")]),e._v(" "),r("p",[e._v("用户点击按钮或按下键盘上的按键会出发类似onclick这样的事件，它会向任务队列添加一个新任务来响应用户的操作，这是js中最基础的异步变成形式，直到事件触发时才执行事件处理程序，且执行上下文与定义的相同。")]),e._v(" "),r("h4",{attrs:{id:"回调模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#回调模式"}},[e._v("#")]),e._v(" 回调模式")]),e._v(" "),r("p",[e._v("参见node.js")]),e._v(" "),r("h3",{attrs:{id:"promise基础知识"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise基础知识"}},[e._v("#")]),e._v(" Promise基础知识")]),e._v(" "),r("h4",{attrs:{id:"promise生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise生命周期"}},[e._v("#")]),e._v(" Promise生命周期")]),e._v(" "),r("p",[e._v("每个promise都会经历一个短暂的生命周期，先是处于进行中的状态，此时操作尚未完成，所以它是未处理的(unsettled);一旦异步操作执行结束，Promise则变为已处理(settled).操作结束后Promise可能会进入到以下状态中的其中一个")]),e._v(" "),r("ul",[r("li",[e._v("Fulfilled:Promise异步操作成功完成")]),e._v(" "),r("li",[e._v("Rejected:由于程序错误或一些其他原因，Promise异步操作未能成功完成。")])]),e._v(" "),r("p",[e._v("所有Promise都有then()方法，接受两个参数，一个是当Promise状态变为fulfilled时要调用的函数，与异步操作相关的附加数据会传递给这个完成函数，第二个是当Promise状态变为rejected时要调用的函数，所有与失败状态相关的附加数据都会传递给这个拒绝函数。\n"),r("u",[e._v("如果一个对象实现了上述的then()方法，那这个对象我们称之为thenable对象，所有Promise都是thenable对象，但并非所有thenable对象都是Promise")]),e._v("\n每次调用then()方法或者catch()方法都会创建一个新任务，当promise被解决(resolved)时执行.这些任务最终会被加入到一个为PROMISE量身定制的独立队列中。")]),e._v(" "),r("h4",{attrs:{id:"创建未完成的promise"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#创建未完成的promise"}},[e._v("#")]),e._v(" 创建未完成的Promise")]),e._v(" "),r("p",[e._v("用Promise构造函数可以创建新的Promise，构造函数只接受一个参数，包含初始化Promise代码的执行器函数。执行器函数接受两个参数，分别是resolve()函数和reject()函数，Promise执行器会立即执行，然后才执行后续流程的代码。\n完成处理程序和拒绝处理程序总是在执行器完成后被添加到任务队列的末尾。(即then/cantch)")]),e._v(" "),r("h4",{attrs:{id:"创建已处理的promise"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#创建已处理的promise"}},[e._v("#")]),e._v(" 创建已处理的Promise")]),e._v(" "),r("ul",[r("li",[e._v("使用Promise.resolve()，只接受一个参数并返回一个完成态的Promise，也就是说不会有任务编排的过程。")]),e._v(" "),r("li",[e._v("Promise.reject(),通过Promise.reject方法创建已拒绝Promise，创建已拒绝Promise")]),e._v(" "),r("li",[e._v("如果向上面的这两个方法传入一个Promise，那么这个Promise会被直接返回。")]),e._v(" "),r("li",[e._v("这两个方法接受非Promise的Thenable对象作为参数。如果传入，则会创建一个新的Promise，并在then()函数中被调用。")]),e._v(" "),r("li",[e._v("拥有then方法并且接受resolve和reject这两个参数的普通对象就是非Promise的Thenable对象")])]),e._v(" "),r("h4",{attrs:{id:"全局promise拒绝处理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#全局promise拒绝处理"}},[e._v("#")]),e._v(" 全局Promise拒绝处理")]),e._v(" "),r("p",[e._v("如果在没有拒绝处理程序的情况下拒绝一个Promise，那么不会提示失败信息")]),e._v(" "),r("h5",{attrs:{id:"nodejs环境的拒绝处理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#nodejs环境的拒绝处理"}},[e._v("#")]),e._v(" Nodejs环境的拒绝处理")]),e._v(" "),r("p",[e._v("Promise拒绝时会出发process对象上的两个事件")]),e._v(" "),r("ul",[r("li",[e._v("unhandledRejection 在一个事件循环中，当Promise被拒绝,并且没有提供拒绝处理程序时，触发该事件。")]),e._v(" "),r("li",[e._v("rejectionHandled 在一个事件循环后,当Promise被拒绝时，若拒绝处理程序被调用，触发该事件。\n拒绝原因(通常是一个错误对象)及被拒绝的Promise作为参数被传入unhandledRejection事件处理程序中。P248")])]),e._v(" "),r("h5",{attrs:{id:"浏览器环境的拒绝处理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器环境的拒绝处理"}},[e._v("#")]),e._v(" 浏览器环境的拒绝处理")]),e._v(" "),r("p",[e._v("浏览器通过在window对象上触发两个事件识别未处理的拒绝。")]),e._v(" "),r("ul",[r("li",[e._v("unhandledrejection 在一个事件循环中，当Promise被拒绝,并且没有提供拒绝处理程序时，触发该事件。")]),e._v(" "),r("li",[e._v("rejectionhandled 在一个事件循环后,当Promise被拒绝时，若拒绝处理程序被调用，触发该事件。\n在浏览器中事件处理程序接受一个有以下属性的事件对象作为参数\ntype 事件名称(unhandledrejection或rejectionhandled)\npromise 被拒绝的promise对象\nreason 来自promise的拒绝值")])]),e._v(" "),r("h4",{attrs:{id:"串联promise"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#串联promise"}},[e._v("#")]),e._v(" 串联Promise")]),e._v(" "),r("p",[e._v("每次调用then或这catch方法时实际上创建并返回了另一个Promise。只有当第一个Promise完成或被拒绝后第二个才会被解决。")]),e._v(" "),r("h4",{attrs:{id:"promise链的返回值"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise链的返回值"}},[e._v("#")]),e._v(" Promise链的返回值")]),e._v(" "),r("p",[e._v("如果在完成处理程序中指定一个返回值，则可以沿着这条链继续传递数据。拒绝处理程序也是一样，返回的值仍可以用在下一个Promise的完成处理程序中。")]),e._v(" "),r("h4",{attrs:{id:"响应多个promise"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#响应多个promise"}},[e._v("#")]),e._v(" 响应多个Promise")]),e._v(" "),r("h4",{attrs:{id:"promise-all"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise-all"}},[e._v("#")]),e._v(" Promise.all")]),e._v(" "),r("p",[e._v("接受一个参数并返回一个Promise，该参数时一个含有多个受监视Promise的可迭代对象（例如数组）。只有当可迭代对象中所有Promise都被解决后返回的Promise才会被解决，只有当可迭代对象中所有Promise都被完成后返回的Promise才会被完成。\n拒绝处理程序总是接受一个值而非数组，因为只要有一个Promise被拒绝则返回的Promise没等所有Promise完成就立即被拒绝，该值来自被拒绝Promise的拒绝值。")]),e._v(" "),r("h4",{attrs:{id:"promise-race"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise-race"}},[e._v("#")]),e._v(" Promise.race")]),e._v(" "),r("p",[e._v("它也接受含多个受监视Promise的可迭代对象作为唯一参数并返回一个Promise，但只要一个Promise被解决返回的Promise就被解决。无须等到所有Promise都被完成，一旦数组中的某个Promise被完成，Promise.race方法也会像Promise.all一样返回一个特定的Promise")]),e._v(" "),r("h4",{attrs:{id:"可作为基类派生其他类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#可作为基类派生其他类"}},[e._v("#")]),e._v(" 可作为基类派生其他类")]),e._v(" "),r("h4",{attrs:{id:"基于promise的异步任务执行"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基于promise的异步任务执行"}},[e._v("#")]),e._v(" 基于Promise的异步任务执行")]),e._v(" "),r("h4",{attrs:{id:"es7-异步"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#es7-异步"}},[e._v("#")]),e._v(" es7 异步")])])}),[],!1,null,null,null);s.default=a.exports}}]);