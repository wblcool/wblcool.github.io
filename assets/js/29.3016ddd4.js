(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{379:function(t,s,n){"use strict";n.r(s);var e=n(42),o=Object(e.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h3",{attrs:{id:"块级声明"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#块级声明"}},[t._v("#")]),t._v(" 块级声明")]),t._v(" "),n("p",[t._v("定义：块级声明用于声明在指定块的作用域之外无法访问的变量。块级作用域亦被称作为词法作用域，存在于")]),t._v(" "),n("ul",[n("li",[t._v("函数内部")]),t._v(" "),n("li",[t._v("块中（字符 { 和 } 之间）")])]),t._v(" "),n("h4",{attrs:{id:"let-声明"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#let-声明"}},[t._v("#")]),t._v(" let 声明")]),t._v(" "),n("p",[t._v("let 声明代替 var声明变量，把当前变量的作用域限制在当前代码块中。")]),t._v(" "),n("h4",{attrs:{id:"const-声明"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#const-声明"}},[t._v("#")]),t._v(" const 声明")]),t._v(" "),n("p",[t._v("使用const声明的是常量，经过设定后不可更改，因此通过const声明的常量必须进行初始化。\nconst声明不允许修改绑定，但允许在赋值为对象时修改其中的值。\nlet，const都不允许对已经声明过的标识符在进行声明。"),n("br"),t._v("\nlet,const用在for-in,for-of中，因为每次迭代不会修改已有绑定，只会创建一个新的绑定。可以避免使用var导致最后访问的都是同一个变量。\n另外const也可使用for循环，但在循环的后续迭代中，执行i++由于试图修改常量因此会报错。")]),t._v(" "),n("hr"),t._v(" "),n("p",[n("b",[t._v("临时死区")]),t._v(" ：let const没有变量声明提升，因此在声明之前访问这些变量即使是使用typeof 也会引发引用错误。即在使用let const声明时，js引擎会把变量放于临时死区中，在声明后才会移除，在声明前访问临时死区的变量就会发生引用错误。（标准并未提到TDZ,但可以这么理解。）而在声明块之外访问未定义的变量，变量即是undefined。")]),t._v(" "),n("p",[t._v("在全局作用域创建变量使用let const不会创建在window全局对象上。")]),t._v(" "),n("p",[t._v("最佳实践：默认使用const，只在确实需要改变变量的值时使用let.")])])}),[],!1,null,null,null);s.default=o.exports}}]);